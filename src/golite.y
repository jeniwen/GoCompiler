%{
#include <stdio.h>
#include <stdlib.h>
#include "tree.h"
#include <stdbool.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

PROG * root;

void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}

%}

%union {
	int intval;
	float floatval;
	char *runeval;
	char *stringval;
	char *identifier;
	struct EXP* exp;
	struct List* list;
	struct STMT* stmt;
	struct TOPSTMT* topstmt;
	struct TYPE* type;
	struct PROG* prog;
	struct SWITCHCASE* switchcase;
}

//%expect 19

//Non-terminal types
%type <list> explist identlist params fielddeclist
%type <exp> exp	fcall	builtin
%type <stmt> forstatement block statementlist simplestatement switchstatement vardecl varspec typedecl typespec typespeclist varspeclist statement ifstatement
%type <topstmt> topdecl topdecls
%type <type> type
%type <prog> program
%type <switchcase> caseclauselist

%nonassoc <intval> tINTVAL

%nonassoc <floatval> tFLOATVAL

%nonassoc <runeval> tRUNEVAL

%nonassoc <stringval> tSTRINGVAL

/* valid operators
/+ /& /+= /&= /&& /== /!= ( )
/- /| /-= /|= /|| /< /<= [ ]
/* /ˆ /*= /ˆ= /<- /> />= { }
// /<< //= /<<= /++ /= /:= /, /;
/% />> /%= />>= /-- /! /... /. /:
/&ˆ /&ˆ=
*/

//KEYWORDS
%nonassoc tBREAK tDEFAULT tFUNC tINTERFACE tSELECT tCASE tDEFER tGO tMAP tSTRUCT tCHAN tELSE tGOTO tPACKAGE tSWITCH tCONST tFALLTHROUGH tIF tRANGE tTYPE tCONTINUE tFOR tIMPORT tRETURN tVAR tPRINT tPRINTLN tAPPEND tLEN tCAP

//based on https://golang.org/ref/spec#Operator_precedence

//BINARY LOGIC
%left tOR
%left tAND

//BINARY COMPARISONS
%left tEQUALS tNE tLT tLE tGT tGE

//ARITHMETIC OPERATORS
%left tPLUS tMINUS tBWOR tBWXOR //last two |, ^
%left tTIMES tDIV tREM tLSHIFT tRSHIFT tBWAND tBWANDNOT //last two are &, &^


//ASSIGNMENTS
%left tBWANDASSIGN tBWORASSIGN /* &=. |=, etc */
//left to right are :=, =, *=, /=, +=, -=, %=, <<=, >>=, ^=, &^=
%left tDEFINE tASSIGN tTIMESASSIGN tDIVASSIGN tPLUSASSIGN tMINUSASSIGN tREMASSIGN tLSHIFTASSIGN tRSHIFTASSIGN tBWXORASSIGN tBWANDNOTASSIGN
%left tARROW //<-

%nonassoc tINC tDEC //++  //--
%nonassoc tELLIPSIS //...
%nonassoc tF tSEMICOLON tCOLON tCOMMA

%nonassoc tDOT // .

%nonassoc <identifier> tIDENTIFIER

//BRACKETS
%left tLPAREN tRPAREN tLBRACE tRBRACE tLBRACKET tRBRACKET

//UNARY
%left tUMINUS tBANG tUPLUS tUBWXOR


/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations

/* Generate detailed error messages */
%error-verbose

%%

program : tPACKAGE tIDENTIFIER tSEMICOLON topdecls {$$ = makeProg($2, $4); root = $$;}
;

topdecls : topdecl topdecls {$$ = $1; if ($$ != NULL) $$->next = $2;}
         |	{$$ = NULL;}
;

topdecl : tFUNC tIDENTIFIER tLPAREN params tRPAREN block tSEMICOLON	{$$ = makeTOPSTMT_funDecl($2, $4, NULL, $6);}
		| tFUNC tIDENTIFIER tLPAREN params tRPAREN block    {$$ = makeTOPSTMT_funDecl($2, $4, NULL, $6);}
		| tFUNC tIDENTIFIER tLPAREN params tRPAREN type block tSEMICOLON {$$ = makeTOPSTMT_funDecl($2, $4, $6, $7);}
		| tFUNC tIDENTIFIER tLPAREN params tRPAREN type block {$$ = makeTOPSTMT_funDecl($2, $4, $6, $7);}
		| tFUNC tIDENTIFIER tLPAREN tRPAREN block tSEMICOLON	{$$ = makeTOPSTMT_funDecl($2, NULL, NULL, $5);}
		| tFUNC tIDENTIFIER tLPAREN tRPAREN block    {$$ = makeTOPSTMT_funDecl($2, NULL, NULL, $5);}
		| tFUNC tIDENTIFIER tLPAREN tRPAREN type block tSEMICOLON {$$ = makeTOPSTMT_funDecl($2, NULL, $5, $6);}
		| tFUNC tIDENTIFIER tLPAREN tRPAREN type block {$$ = makeTOPSTMT_funDecl($2, NULL, $5, $6);}
		| vardecl tSEMICOLON {$$ = makeTOPSTMT_vartypeDecl($1);}
		| vardecl {$$ = makeTOPSTMT_vartypeDecl($1);}
		| typedecl tSEMICOLON {$$ = makeTOPSTMT_vartypeDecl($1);}
		| typedecl {$$ = makeTOPSTMT_vartypeDecl($1);}
;


type : tIDENTIFIER	{$$ = makeTYPE_ident($1);}
	 | tLBRACKET tINTVAL tRBRACKET type	{$$ = makeTYPE_array($4 , $2);}
	 | tSTRUCT tLBRACE fielddeclist tRBRACE  {$$ = makeTYPE_struct($3);}
	 | tLPAREN type tRPAREN	{$$ = $2;}
	 | tLBRACKET tRBRACKET type	{$$ = makeTYPE_slice($3);}
;

fielddeclist: identlist type tSEMICOLON fielddeclist {$$ = makeList_param($1, $2); $$->nextli = $4;}
			 |	{$$ = NULL;}

vardecl : tVAR varspec {$$ = $2;}
        | tVAR tLPAREN varspeclist tRPAREN {$$ = $3;}
;

varspeclist : varspec tSEMICOLON varspeclist { $$ = $1; if($1 != NULL){$$->val.declStmt.nextd = $3;}}
			|  {$$ = NULL;}
;

varspec : identlist type {$$ = makeSTMT_varDecl($1, $2, NULL);}
        | identlist tASSIGN explist	{$$ = makeSTMT_varDecl($1, NULL, $3);}
		| identlist type tASSIGN explist {$$ = makeSTMT_varDecl($1, $2, $4);}
;

explist : exp tCOMMA explist	{$$ = makeList_exp($1); $$->nextli = $3;}
		| exp	{$$ = makeList_exp($1) ; $$->nextli = NULL;}
;

identlist : tIDENTIFIER tCOMMA identlist	{$$ = makeList_ident($1); $$->nextli = $3;}
		  | tIDENTIFIER	{$$ = makeList_ident($1); $$->nextli = NULL;}
;

typedecl : tTYPE typespec {$$ = $2;}
		 | tTYPE tLPAREN typespeclist tRPAREN {$$ = $3;}
;

typespeclist : typespec tSEMICOLON typespeclist	{$$ = $1; $$->val.typeDecl.nextT = $3;}
          |	{$$ = NULL;}
;

typespec : tIDENTIFIER type {$$ = makeSTMT_typeDecl($1, $2);}
;

params : identlist type tCOMMA params {$$ = makeList_param($1, $2); $$->nextli = $4;}
	   | identlist type 	{$$ = makeList_param($1, $2); $$->nextli = NULL;}
;

block : tLBRACE statementlist tRBRACE {$$ = makeSTMT_block($2);}
;

statementlist : statement statementlist {$$ = $1; if ($$ != NULL) $$->next = $2; else $$ = $2;}
			  |	{$$ = NULL;}
;

simplestatement : exp 					{$$ = makeSTMT_expStatement($1);}
				| exp tINC 			{$$ = makeSTMT_incdecSTMT($1, true);}
				| exp tDEC			{$$ = makeSTMT_incdecSTMT($1, false);}
				| explist tASSIGN explist 	{$$ = makeSTMT_assignSTMT($1,$3);}
				| exp tREMASSIGN exp 		{$$ = makeSTMT_assignopSTMT($1, assignopKindRemainder, $3);}
				| exp tTIMESASSIGN exp		{$$ = makeSTMT_assignopSTMT($1, assignopKindMultiplication, $3);}
				| exp tDIVASSIGN exp 		{$$ = makeSTMT_assignopSTMT($1, assignopKindDivision, $3);}
				| exp tPLUSASSIGN exp 		{$$ = makeSTMT_assignopSTMT($1, assignopKindPlus, $3);}
				| exp tMINUSASSIGN exp  	{$$ = makeSTMT_assignopSTMT($1, assignopKindMinus, $3);}
				| exp tLSHIFTASSIGN exp 	{$$ = makeSTMT_assignopSTMT($1, assignopKindLShift, $3);}
				| exp tRSHIFTASSIGN exp 	{$$ = makeSTMT_assignopSTMT($1, assignopKindRShift, $3);}
				| exp tBWXORASSIGN exp  	{$$ = makeSTMT_assignopSTMT($1, assignopKindBWXor, $3);}
				| exp tBWANDNOTASSIGN exp 	{$$ = makeSTMT_assignopSTMT($1, assignopKindBWAndNot, $3);}
				| exp tBWANDASSIGN exp  	{$$ = makeSTMT_assignopSTMT($1, assignopKindBWAnd, $3);}
				| exp tBWORASSIGN exp  		{$$ = makeSTMT_assignopSTMT($1, assignopKindBWOr, $3);}
				| explist tDEFINE explist  	{$$ = makeSTMT_shortassignSTMT($1, $3);}
				|							{$$ = NULL;}
;


statement : block
		  | vardecl tSEMICOLON
		  | typedecl tSEMICOLON
		  | tPRINT tLPAREN explist tRPAREN tSEMICOLON 	{$$ = makeSTMT_print(statementKindPrint, $3);}
		  | tPRINT tLPAREN tRPAREN tSEMICOLON 			{$$ = makeSTMT_print(statementKindPrint, NULL);}
		  | tPRINTLN tLPAREN explist tRPAREN tSEMICOLON {$$ = makeSTMT_print(statementKindPrintln, $3);}
		  | tPRINTLN tLPAREN tRPAREN tSEMICOLON 		{$$ = makeSTMT_print(statementKindPrintln, NULL);}
		  | ifstatement tSEMICOLON 						{$$ = $1;}
		  | switchstatement
		  | forstatement
		  | tRETURN exp	tSEMICOLON 						{$$ = makeSTMT_returnStmt($2);}
		  | tRETURN	tSEMICOLON 							{$$ = makeSTMT_returnStmt(NULL);}
		  | tBREAK tSEMICOLON 							{$$ = makeSTMT_breakStmt();}
		  | tCONTINUE	tSEMICOLON 						{$$ = makeSTMT_continueStmt();}
		  | simplestatement tSEMICOLON

;

exp : tINTVAL 				{$$ = makeEXP_intLiteral($1);}
	| tRUNEVAL 				{$$ = makeEXP_runeLiteral($1);}
	| tFLOATVAL				{$$ = makeEXP_floatLiteral($1);}
	| tSTRINGVAL 			{$$ = makeEXP_stringLiteral($1);}
	| tLPAREN exp tRPAREN 	{$$ = $2; $$->paren = true;}
	| tIDENTIFIER 			{ $$ = makeEXP_identifier($1);}
	| builtin
	| exp tOR exp 					{$$ = makeEXP_binary(expressionKindOr, $1, $3);}
	| exp tAND exp					{$$ = makeEXP_binary(expressionKindAnd, $1, $3);}
	| exp tTIMES exp				{$$ = makeEXP_binary(expressionKindMultiplication, $1, $3);}
	| exp tDIV exp					{$$ = makeEXP_binary(expressionKindDivision, $1, $3);}
	| exp tREM exp					{$$ = makeEXP_binary(expressionKindModulo, $1, $3);}
	| exp tLSHIFT exp				{$$ = makeEXP_binary(expressionKindLeftShift, $1, $3);}
	| exp tRSHIFT exp				{$$ = makeEXP_binary(expressionKindRightShift, $1, $3);}
	| exp tBWAND exp				{$$ = makeEXP_binary(expressionKindBitwiseAnd, $1, $3);}
	| exp tBWANDNOT exp				{$$ = makeEXP_binary(expressionKindBitwiseAndNot, $1, $3);}
	| exp tPLUS exp					{$$ = makeEXP_binary(expressionKindAddition, $1, $3);}
	| exp tMINUS exp				{$$ = makeEXP_binary(expressionKindSubtraction, $1, $3);}
	| exp tBWOR exp					{$$ = makeEXP_binary(expressionKindBitwiseOr, $1, $3);}
	| exp tBWXOR exp				{$$ = makeEXP_binary(expressionKindBitwiseXor, $1, $3);}
	| exp tEQUALS exp				{$$ = makeEXP_binary(expressionKindEquals, $1, $3);}
	| exp tNE exp					{$$ = makeEXP_binary(expressionKindNotEquals, $1, $3);}
	| exp tLT exp					{$$ = makeEXP_binary(expressionKindLower, $1, $3);}
	| exp tLE exp					{$$ = makeEXP_binary(expressionKindLeq, $1, $3);}
	| exp tGT exp					{$$ = makeEXP_binary(expressionKindGreater, $1, $3);}
	| exp tGE exp					{$$ = makeEXP_binary(expressionKindGeq, $1, $3);}
	| tPLUS exp %prec tUPLUS 		{$$ = makeEXP_unary(expressionKindUnaryPlus, $2);}
	| tMINUS exp %prec tUMINUS		{$$ = makeEXP_unary(expressionKindUnaryMinus, $2);}
	| tBANG exp						{$$ = makeEXP_unary(expressionKindUnaryNot, $2);}
	| tBWXOR exp %prec tUBWXOR		{$$ = makeEXP_unary(expressionKindBitComplement, $2);}
	| exp tDOT tIDENTIFIER 			{$$ = makeEXP_structFieldAccess($1, $3);}
	| exp tLBRACKET exp tRBRACKET 	{$$ = makeEXP_arrayAccess($1, $3);}
	| fcall
;


fcall : exp tLPAREN explist tRPAREN	 { if($1->kind != expressionKindIdentifier){fprintf(stderr, "Error: (line %d) incorrect function call\n", yylineno); exit(1);} $$ = makeEXP_funCall($1, $3);}
	  | exp tLPAREN tRPAREN {if($1->kind != expressionKindIdentifier){fprintf(stderr, "Error: (line %d) incorrect function call\n", yylineno); exit(1);} $$ = makeEXP_funCall($1, NULL);}
;

builtin : tAPPEND tLPAREN exp tCOMMA exp tRPAREN	{$$ = makeEXP_append($3, $5);}
		| tLEN tLPAREN exp tRPAREN	{$$ = makeEXP_lencap(expressionKindLen, $3);}
		| tCAP tLPAREN exp tRPAREN	{$$ = makeEXP_lencap(expressionKindCap, $3);}
;


ifstatement : tIF simplestatement tSEMICOLON exp block	{$$ = makeSTMT_ifStmt($2, $4, $5, NULL, NULL);}
			| tIF simplestatement tSEMICOLON exp block tELSE ifstatement	{$$ = makeSTMT_ifStmt($2, $4, $5, NULL, $7);}
			| tIF simplestatement tSEMICOLON exp block tELSE block 	{$$ = makeSTMT_ifStmt($2, $4, $5, $7 , NULL);}
			|	tIF exp block	{$$ = makeSTMT_ifStmt(NULL, $2, $3, NULL, NULL);}
			| tIF exp block tELSE ifstatement	{$$ = makeSTMT_ifStmt(NULL, $2, $3, NULL, $5);}
			| tIF exp block tELSE block	 {$$ = makeSTMT_ifStmt(NULL, $2, $3, $5 , NULL);}
;


switchstatement	: tSWITCH simplestatement tSEMICOLON exp  tLBRACE caseclauselist tRBRACE tSEMICOLON {$$ = makeSTMT_switchStmt($2, $4,  $6);}
				| tSWITCH exp tLBRACE caseclauselist tRBRACE tSEMICOLON	{$$ = makeSTMT_switchStmt(NULL, $2,  $4);}
				| tSWITCH simplestatement tSEMICOLON tLBRACE caseclauselist tRBRACE tSEMICOLON	{$$ = makeSTMT_switchStmt($2, NULL,  $5);}
				| tSWITCH tLBRACE caseclauselist tRBRACE tSEMICOLON	{$$ = makeSTMT_switchStmt(NULL, NULL,  $3);}
;

caseclauselist : tCASE explist tCOLON statementlist caseclauselist {$$ = makeSWITCHCASE($2, $4, false); $$->next = $5;}
			   |	tDEFAULT tCOLON statementlist caseclauselist {$$ = makeSWITCHCASE(NULL, $3, true); $$->next = $4;}
				 | {$$ = NULL;}


forstatement : tFOR exp block tSEMICOLON {$$ = makeSTMT_forStmt($2, NULL, NULL, $3);}
			 | tFOR block	tSEMICOLON {$$ = makeSTMT_forStmt(NULL, NULL, NULL, $2);}
			 | tFOR simplestatement tSEMICOLON exp tSEMICOLON simplestatement block	tSEMICOLON {$$ = makeSTMT_forStmt($4, $2, $6, $7);}
			 | tFOR simplestatement tSEMICOLON tSEMICOLON simplestatement block	tSEMICOLON {$$ = makeSTMT_forStmt(NULL, $2, $5, $6);}
 ;
%%
